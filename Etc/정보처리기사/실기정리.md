

#### 1. 디자인 패턴
- GoF 디자인 패턴
![image](https://user-images.githubusercontent.com/24931069/194764409-009be4fb-fc3a-4b34-8464-51697bbc77ae.png)
참고) https://gmlwjd9405.github.io/2018/07/06/design-pattern.html

- Factory Method
  - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴으로, 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다. 다른 이름으로 가상 생성자(Virtual Constructor) 패턴이라고도 불린다.

#### 2. 파일의 구조
- 파일의 구조는 파일을 구성하는 레코드들이 보조기억장치에 편성되는 방식을 의미하는 것으로 크게 **순차, 색인(Index), 해싱**으로 구성된다.
- 색인 파일 구조는 <값,주소> 쌍으로 구성되는 데이터 구조를 활용하여 데이터에 접근하는 방식으로, 자기 디스크에서 주로 활용된다.

#### 3. UML(Unified Modeling Language)
- 통합 모델링 언어를 사용하여 시스템 상호작용, 업무흐름, 시스템 구조, 컴포넌스 관계 등을 그린 도면입니다.
- UML 다이어그램을 사용하는 이유는 프로그래밍을 단순화시켜 표현하여 의사소통하기도 좋고
- 대규모 프로젝트 구조의 로드맵을 만들거나 개발을 위한 시스템 구축에 기본을 마련합니다.
##### 1) 종류
- Use Case 다이어그램 : 요구 분석 과정에서 시스템과 외부와의 상호작용을 묘사함
- Activity 다이어그램 : 업무의 흐름을 모델링하거나 객체의 생명주기를 표현함
- Sequence 다이어그램 : 객체 간의 메시지 전달을 시간적 흐름에서 분석함
- Collaboration 다이어그램 : 객체와 객체가 주고받는 메시지 중심의 작성
- Class 다이어그램 : 시스템의 구조적인 모습을 그림
  - UML 다이어그램 중 객체(Object)들을 **클래스**로 추상화하여 표현하는 다이어그램으로 대표적인 구조적 다이어그램이다.
- Component 다이어그램 : 소프트웨어 구조를 그림
- Deployment 다이어그램 : 기업 환경의 구성과 컴포넌트들 간의 관계를 그림
참고) https://m.blog.naver.com/icbanq/221781238065

##### 2) 관계
- 사물과 사물 사이의 연관성을 표현
![image](https://user-images.githubusercontent.com/24931069/194765804-a1423049-343f-4942-935c-84515db16bfd.png)
참고) https://www.nextree.co.kr/p6753/

#### 4. 인터페이스
UI : 사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 감정 및 경험
UX : 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 

#### 5. 결합도(Coupling)와 응집도(Cohesion)
- 결합도
  - 모듈 내부가 아닌 외부의 모듈과 연관도 또는 모듈 간의 상호의존성을 나타내는 정도
  - 소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도
  - 특징
    - 모듈 연관성 없음
    - 인터페이스 의존성
    - 복잡성 감소
    - 파급효과 최소화
  - 유형(순서대로 결합도가 낮아진다)
    - 내용 결합도(Content Coupling)
    - 공통 결합도(Common Coupling)
    - 외부 결합도(External Coupling)
    - 제어 결합도(Control Coupling)
    - 스탬프 결합도(Stamp Coupling)
    - 자료 결합도(Data Coupling)
- 응집도
  - 모듈의 독립성을 나타내는 개념으로, 모듈 내부 구성요소 간 연관 정도
  - 정보 은닉의 확장개념으로 하나의 모듈은 하나의 기능을 수행하는 것을 의미 
  - 특징
    - 유사기능 영역 구성
    - 단일 책임할당
    - 함수 간 상호협력
  - 유형(순서대로 응집도가 높아진다)
    - 우연적 응집도(Coincidental Cohesion)
    - 논리적 응집도(Logical Cohesion)
    - 시간적 응집도(Temporal Cohesion)
    - 절차적 응집도(Procedural Cohesion)
    - 통신적 응집도(Communication Cohesion)
    - 순차적 응집도(Sequential Cohesion)
    - 기능적 응집도(Functional Cohesion)
참고) https://computer-science-student.tistory.com/140

------------

#### 4. 애플리케이션 테스트
- 상향식 통합 테스트 : 소프트웨어의 **하위 모듈**에서 **상위 모듈 방향**으로 통합하면서 테스트하는 기법
  - 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 **클러스터(Cluster)**가 필요하다.
  - 데이터의 입,출력을 확인하기 위해 더미 모듈인 **드라이버(Driver)**를 생성한다.
- 하향식 통합 테스트 : 소프트웨어의 **상위 모듈**에서 **하위 모듈 방향**으로 통합하면서 테스트하는 기법
- 혼합식 통합 테스트 : 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용해 최적의 테스트를 지원하는 방식

##### 1) 화이트박스 테스트
- 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법
- 테스트 과정의 초기에 적용
- 모듈 안의 작동을 직접 관찰
##### - 종류
- 기초 경로 검사
- 조건 검사
- 루프 검사
- 데이터 흐름 검사
##### - 테스트 검증 기준
- 문장 검증 기준 : **모든 구문이 한 번 이상 수행**되도록 테스트 케이스 설계
- 분기 검증 기준 : **모든 조건문이 한 번 이상 수행**되도록 테스트 케이스 설계
- 조건 검증 기준 : **모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행**되도록 테스트 케이스 설계
- 분기/조건 기준 : **모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행**되도록 테스트 케이스 설계

##### 2) 블랙박스 테스트
- 각 기능이 완전히 작동되는 것을 입증하는 테스트
- 기능 테스트라고도 함
- 요구사항 명세를 보면서 테스트하는 것
- 소프트웨어 인터페이스에서 실시되는 테스트
##### - 종류
- 동치 분할 검사(Equivalence Partitioning Testing)
- 경계값 분석(Boundary Value Analysis)
- 원인-효과 그래프 검사(**Cause-Effect Graphing Testing**)
  - 그래프를 활용하여 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
  - 오류 예측 검사(Error Guessing)
  - 비교 검사(Comparison Testing)

------------

### ＊데이터베이스
#### 1. 데이터베이스의 상태 변화를 일으키는 트랜잭션(Transaction)의 특성
- 원자성(Atomicity)
   - 트랜잭션과 관련된 작업들이 모두 정상적으로 수행되거나 아예 하나도 실행되지 않아야한다는 All-or-Nothing 방식을 의미
   - **OR 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야한다는 특성을 의미**
 - 일관성(Consistency)
   - 트랜잭션이 성공적으로 실행되고 난 이후로 데이터베이스가 일관적으로 상태를 유지하는 것을 의미
 - 격리성(Isolation)
   - 하나의 트랜잭션을 통해 SQL 연산이 실행되는 도중에 다른 트랜잭션 연산 작업이 끼어들지 못하게 보장하는 것
 - 지속성(Durability)
   - 트랜잭션이 성공적으로 수행되고 난 이후 시스템의 오류 등과 같은 어떠한 경우에도 데이터가 손실되지 않고 그 결과가 영원히 반영되어야 한다.
참고) https://iwuooh.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Database-Transaction%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-4%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%84%B1?category=982116#:~:text=%EC%9D%B4%EB%A1%A0%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80,(Durability)%EC%9D%84%20%EB%B3%B4%EC%9E%A5%ED%95%9C%EB%8B%A4.


#### 2. 데이터 언어
##### 1) DML(Data Manipulation Language) : 데이터 조작어
```
SELECT, INSERT, UPDATE, DELETE
```
##### 2) DDL(Data Definition Language) : 데이터 정의어
```
CREATE, ALTER, DROP, RENAME, TRUNCATE
```
##### 3) DCL(Data Control Language) : 데이터 제어어
```
★GRANT:데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하는데 사용하는 명령어이다.
REVOKE:
```
##### 4) TCL(Transaction Control Language) : 트랜잭션 제어어
```
COMMIT, ROLLBACK, SAVEPOINT
```
참고) https://brownbears.tistory.com/180


#### 3. SQL문
- 조인
```
교차 조인(CROSS JOIN) :  왼쪽 테이블의 데이터 1개당 오른쪽 테이블 데이터를 처음부터 끝까지 하나씩 결합한다. 그리고 왼쪽의 데이터가 없어질 때까지 반복한다. 
참고) https://araikuma.tistory.com/726
```
- 정렬
```
오름차순:asc (1,2,3,4 ...)
내림차순:desc (4,3,2,1 ...)
```
- 

#### 4. 정규화
```
문제가 생길 수 있는 커다란 테이블을 문제가 없도록 작은 테이블로 나누는 것
하지만 나누는 정도에 따라 규칙(제약조건)이 있고 그 정도를 정규형이라고 부른다
정규형은 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF가 있는데, 
차수가 높아질 수록 규칙(제약조건)이 까다로워진다.
그래서 일반적으로는 1~3NF(또는 ~BCNF)까지만 사용하고 
나머지 정규형은 학문적 용도(전공, 수업, 논문 등)로 사용된다.
```
1. 1NF(제 1정규형) : 테이블(릴레이션)에 각 **도**메인은 원자성(Atomicity)을 가진다.
  - 셀이 더 작게 나눌 수 없는 단일 값을 가진다.
2. 2NF(제 2정규형) : 1NF를 먼저 충족시켜야 진행 가능하고, 속성 값의 결정이 기본키(또는 복합키)의 전체를 참조해야한다.
  - 완전 함수 종속을 만족하도록 테이블을 분해
  - 여기서 완전 함수 종속이란 기본키의 **부**분 집합이 결정자가 되어선 안된다는 것을 의미 
3. 3NF(제 3정규형) : 3NF도 2NF를 충족시킨 상태에서 진행 가능하고, 3NF는 모든 속성이 기본키(또는 복합키)에 **이**행적 함수 종속이 되지 않아야한다.
  - 이행적 함수 종속이란 X->Y고 Y->Z면 X->Z가 되는 것을 말한다.
4. BCNF 정규화 : 제 3정규화를 진행한 테이블에 대해 모든 **결**정자가 후보키가 되도록 테이블을 분해하는 것이다.
5. 4NF(제 4정규형) : **다**치 종속 제거
6. 5NF(제 5정규형) : **조**인 종속성 이용
참고) https://chankim.tistory.com/9

#### 5. 로킹(Locking)
- 데이터베이스의 병행제어 기법 중 하나
- 접근한 데이터에 대한 연산을 모두 마칠 때까지 추가적인 접근을 제한함으로써 상호 배타적으로 접근하여 작업을 수행하도록 하는 기법
```
쉽게 설명)
한번에 한명만 사용할 수 있게 하는 단위를 "로킹 단위"라 하는데
ex) 어떤 프로젝트의 소스를 여러 사람이 동시에 작업할 경우,
    누군가가 특정 파일을 건들고 있을 때, 
    다른 사용자는 그 파일을 건들지 못하도록 하는 것이 로킹
    이 때 로킹 단위 = 파일이 된다.
ex) 어떤 사람이 어떤 폴더에 있는 파일을 작업하고 있을 때
    그 폴더에 아예 접근 못하게 하게 되면
    이 때 로킹 단위 = 폴더가 된다.
ex) 한명씩 차례로 작업할 수만 있고, 누군가가 작업 중이고
    아예 프로젝트에 접근 못하도록 한다면,
    이 때 로킹 단위 = 프로젝트가 된다.
```
```
이 때 단위별로 나누어진 하나하나를 '로크'라고 하는데
로킹 단위를 '파일'로 하자면, 
파일 하나하나가 '로크'가 되니 당연히 그 수가 많아질테고
로킹 단위를 '폴더'로 하자면 훨씬 줄어들테고
로킹 단위를 '프로젝트'로 하면 로크는 1개밖에 없게 된다.

따라서 데이터베이스 트랜젝션에서도 로킹 단위는 파일, 레코드, 필드와 같이 여러가지로 나누어질 수도 있고

로킹 단위가 크면(ex프로젝트) -> 로크의 수가 적어지고 -> 제어 기법이 간단해지고 -> 병행성이 감소한다.
로킹 단위가 작으면(ex파일) -> 로크의 수가 많아지고 -> 제어하기 까다로우며 -> 병행성이 증가한다.
```
참고) https://raisonde.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%A1%9C%ED%82%B9Locking-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EB%A1%9C%ED%82%B9-%EB%8B%A8%EC%9C%84

------------

### ＊네트워크
#### OSI 7 Layer
- 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocal)이다.
```
물리(Physical) 계층
데이터링크(Data-Link) 계층 : 물리적으로 연결된 두 개의 인접한 개방 시스템들 간에 신뢰성있고 효율적인 정보 전송을 할 수 있도록 연결 설정, 데이터 전송, 오류 제어 등의 기능을 수행한다.
네트워크(Network) 계층 : 개방 시스템들 간의 네트워크 연결을 관리하며, 경로 제어, 패킷 교환, 트래픽 제어 등의 기능을 수행한다.
전송(Transport) 계층
세션(Session) 계층 
표현(Presentation) 계층 : 서로 다른 데이터 표현 형태를 갖는 시스템의 상호 접속을 위해 필요한 계층으로, 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색 등의 기능을 수행한다.
응용(Application) 계층
```

#### Ad-hoc Network
- 재난 및 군사 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크이다.
- 망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합하다.
- 멀티 홉 라우팅 기능을 지원한다.

#### 패킷 교환 방식
- 패킷 교환 방식은 접속 방식에 따라서 데이터 그램 방식과 가상회선 방식으로 구분된다.
![image](https://user-images.githubusercontent.com/24931069/194769028-99e2dae3-1a3a-49fd-b89f-cd3fcdd5cdfb.png)
##### 1) 데이터그램
- **비연결형 통신에서 주로 사용하는 방식으로, 사전에 접속 절차를 수행하지 않고 헤더에 출발지에서 목적지까지의 경로 지정을 위한 충분한 정보를 붙여서 개별적으로 전달하는 방식**
- 데이터를 전송하기 전에 논리적 연결이 설정되지 않으며 패킷이 독립적으로 전송된다.
- 패킷을 수신한 라우터는 최적의 경로를 선택하여 패킷을 전송하는데 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있다.(비연결 지향형)
- 송신 측에서 전송한 순서와 수신 측에 도착한 순서가 다를 수 있다.

##### 2) 가상회선(VC)
![image](https://user-images.githubusercontent.com/24931069/194769043-73ac16f0-b0ec-4698-a774-da4be15a74c1.png)
- **연결형 통신에서 주로 사용되는 방식으로, 출발지와 목적지의 전송 경로를 미리 연결하여 논리적으로 고정한 후 통신하는 방식**
- 데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 한다.(연결 지향형)
- 각 패킷에는 가상회선 식별 번호(VCI)가 포함되고, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착한다.
- 데이터 그램은 패킷마다 라우터가 경로를 선택하지만, 가상회선 방식은 경로를 설정할 때 한 번만 수행한다.
참고) [https://jineer.tistory.com/50](https://woovictory.github.io/2018/12/28/Network-Packet-Switching-Method/)

------------

### ＊프로그래밍
#### 1. 연산
- True / False
```
true : 1
false : 0
```
- 비트 연산
```
& : 모두 1이면 1 반환
| : 하나라도 1이면 1반환
~ : 반전
^(XOR) : 서로 다르면 1 반환, **즉 다르면 1, 같으면 0**
<< : 지정한 수만큼 비트들을 전부 왼쪽으로 이동
>> : 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동
```

#### 2. Python
False, True

#### 3. C
##### 1) 구조체
- 구조체의 멤버를 지정할 때는 [변수명].[멤버이름]으로 지정하지만 포인터 변수를 이용해 구조체의 멤버를 지정할 때는 [변수명]->[멤버이름]으로 지정한다.
```
...

struct jsu {
  char nae[12];
  int os, db, hab, hhab;
};

int main() {
  struct jsu st[3] = { {"데이터1", 95, 88}, {"데이터2", 84, 91}, {"데이터3", 86, 75} };
  struct jsu *p;
  p = &st[0];
  (p+1)->hab = (p+1)->os + (p+2)->db;
  (p+1)->hhab = (p+1)->hab + p->os + p->db;
  printf("%d", (p+1)->hab + (p+1)->hhab);
}
```
```
        char nae[12]              int os   int db     int hab     int hhab
st[0]   |데|이|터|1|\0| | | | |    95        88
st[1]   |데|이|터|2|\0| | | | |    84        91
st[2]   |데|이|터|3|\0| | | | |    86        75
```

##### 2) 포인터
```
...

int* array[3];
int a = 12, b = 24, c = 36;
array[0] = &a;
array[1] = &b;
array[2] = &c;

*array[1] : array[1]의 주소값이 가리키는 곳의 값 = 24
**array : array의 주소값이 가리키는 곳의 값 = 12
```

------------

### ＊보안

#### 암호화 알고리즘
- DES
   - 1974년 IBM이 개발하고 1975년 NBS에 의해 미국의 국가 표준으로 발표된 암호화 알고리즘
   - 블록 크기는 64비트, 키 길이는 56비트이며, 16회의 라운드를 수행한다.
   - 컴퓨터 기술이 발달함에 따라 해독이 쉬워지면서 미국의 국가 표준이 2001년 AES로 대체되었다.
- AES
   - 2001년 미국 표준 기술 연구소(NIST)에서 발표한 대칭키 암호화 알고리즘이다.
   - DES의 한계를 느낀 NIST에서 공모한 후 발표하였다.
   - 블록 크기는 128비트이며, 키 길이에 따라서 128, 192, 256으로 분류된다.

ARP 스푸핑 : 로컬 네트워크(LAN)에서 사용하는 ARP 프로토콜의 취약점을 이용한 공격 기법으로, 자신의 물리적 주소(MAC)를 변조하여 다른 PC에 도달해야 하는 데이터 패킷을 가로채거나 방해한다.
