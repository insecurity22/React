### ＊소프트웨어 

#### 1. 디자인 패턴
- GoF 디자인 패턴
![image](https://user-images.githubusercontent.com/24931069/194764409-009be4fb-fc3a-4b34-8464-51697bbc77ae.png)
참고) https://gmlwjd9405.github.io/2018/07/06/design-pattern.html

- Factory Method
  - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴으로, 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다. 다른 이름으로 가상 생성자(Virtual Constructor) 패턴이라고도 불린다.
  - 아래 사이트 설명 짱,, 바로 이해,,,,
  ex) https://sup2is.github.io/2020/06/23/factory-method-pattern.html

#### 2. 객체지향 분석
- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 이와 연관된 속성과 연산, 그들간의 관계 등을 정의하여 모델링하는 작업이다.
- 방법론
  - Rumbaugh(럼바우) 방법
    - 가장 일반적으로 사용되는 방법으로 분석 활동을 **객체 모델, 동적 모델, 기능 모델**로 나누어 수행하는 방법
    ```
      Object or Information: 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 표시하는 모델링
      ex) ER 다이어그램(ERD)
      Dynamic: 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링
      ex) 상태 변화도(STD), 사건 추적도
      Function: 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링
      ex) 자료 흐름도(DFD)
    ```
  - Booch(부치) 방법
    - Use Case를 강조하여 사용하는 분석 방법
  - Coad와 Yourdon 방법
    - E-R 다이어그램을 사용하여 개체의 활동들을 데이터 모델링하는데 초점을 둔 기법
  - Wirfs-Brock 방법
    - 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계작업까지 연속적으로 수행하는 기법

#### 3. 요구사항 정의 및 확인
- 요구사항 내용의 종류에 따라 **기능적 요구사항과 비기능적 요구사항**으로 나눌 수 있다.
  - 기능 요구사항
    - 시스템이 무엇을 하는지, 어떤 기능을 하는지 등 사용자가 시스템을 통해 제공받기를 원하는 기능이나 시스템이 반드시 수행해야하는 기능을 의미한다.
  - 비기능 요구사항
    - 품질이나 제약사항과 관련된 요구사항으로, 시스템의 장비 구성, 성능, 인터페이스, 테스트, 보안 등의 요구사항을 말한다.
- 요구사항이 무엇인지 이해함으로써 요구사항에 적합한 소프트웨어를 만들 수 있다.

#### 4. 모듈 연계 방법
- 모듈 연계는 내부 모듈과 외부 모듈 또는 내부 모듈 간의 데이터의 교환을 위해 관계를 설정하는 것으로 대표적인 모듈 연계 방법에는 EAI와 ESB 방식이 있다.
- EAI(Enterprise Application Integeration)
  - 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션으로 다양한 방식으로 구축이 가능
  - 유형
    - Point-to-Point
    - Hub&Spoke
    - Message Bus
    - Hybrid
- ESB(Enterprise Service Bus)
참고) https://lipcoder.tistory.com/315

------------

#### 2. 파일의 구조
- 파일의 구조는 파일을 구성하는 레코드들이 보조기억장치에 편성되는 방식을 의미하는 것으로 크게 **순차, 색인(Index), 해싱**으로 구성된다.
- 색인 파일 구조는 <값,주소> 쌍으로 구성되는 데이터 구조를 활용하여 데이터에 접근하는 방식으로, 자기 디스크에서 주로 활용된다.

#### 3. UML(Unified Modeling Language)
- 소프트웨어 시스템을 개발하는 과정에서 산출물의 명세화, 시각화, 문서화할 때 사용하는 모델링 언어로써 하나의 시스템을 표현하기 위한 표준적인 방법을 제공하기 위해서 만들어졌다.
- 통합 모델링 언어를 사용하여 시스템 상호작용, 업무흐름, 시스템 구조, 컴포넌스 관계 등을 그린 도면입니다.
- UML 다이어그램을 사용하는 이유는 프로그래밍을 단순화시켜 표현하여 의사소통하기도 좋고
- 대규모 프로젝트 구조의 로드맵을 만들거나 개발을 위한 시스템 구축에 기본을 마련합니다.
##### 1) UML Diagram의 종류
##### - 구조 다이어그램
- 클래스(Class) 다이어그램 : 시스템의 구조적인 모습을 그림
  - UML 다이어그램 중 객체(Object)들을 **클래스**로 추상화하여 표현하는 다이어그램으로 대표적인 구조적 다이어그램이다.
- 객체(Object) 다이어그램
- 패키지(Package) 다이어그램
- 컴포넌트(Component) 다이어그램 : 소프트웨어 구조를 그림
- 배치(Deployment) 다이어그램 : 기업 환경의 구성과 컴포넌트들 간의 관계를 그림

##### - 행위 다이어그램
- 쓰임새(Use Case) 다이어그램 : 사용자 관점에서 바라본 시스템을 표현한 다이어그램
- 활동(Activity) 다이어그램 : 업무의 흐름을 모델링하거나 객체의 생명주기를 표현함
- 상태(State) 다이어그램 : 하나의 객체가 다른 객체와의 상호 작용에 따라 어떻게 변화하는지 표현하는 다이어그램
- 순서(Sequence) 다이어그램 : 객체 간의 메시지 전달을 시간적 흐름에서 분석함
- 통신(Communication=Callaboration=Interaction) 다이어그램 : 객체와 객체가 주고받는 메시지 중심의 작성
참고) https://m.blog.naver.com/icbanq/221781238065
참고) https://seulhee030.tistory.com/56
참고) https://m.blog.naver.com/msoffice7/221740368928

##### 2) 관계
- 사물과 사물 사이의 연관성을 표현
![image](https://user-images.githubusercontent.com/24931069/194765804-a1423049-343f-4942-935c-84515db16bfd.png)
참고) https://www.nextree.co.kr/p6753/

#### 4. 인터페이스
UI : 사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 감정 및 경험
UX : 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 

------------

#### ＊애플리케이션 테스트
- 상향식 통합 테스트 : 소프트웨어의 **하위 모듈**에서 **상위 모듈 방향**으로 통합하면서 테스트하는 기법
  - 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 **클러스터(Cluster)**가 필요하다.
  - 데이터의 입,출력을 확인하기 위해 더미 모듈인 **드라이버(Driver)**를 생성한다.
- 하향식 통합 테스트 : 소프트웨어의 **상위 모듈**에서 **하위 모듈 방향**으로 통합하면서 테스트하는 기법
  - **스텁(Stub)**
- 혼합식 통합 테스트 : 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용해 최적의 테스트를 지원하는 방식

##### 1) 화이트박스 테스트
- 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법
- 테스트 과정의 초기에 적용
- 모듈 안의 작동을 직접 관찰
##### - 종류
- 기초 경로 검사
- 조건 검사
- 루프 검사
- 데이터 흐름 검사
##### - 테스트 검증 기준
- 문장 검증 기준 : **모든 구문이 한 번 이상 수행**되도록 테스트 케이스 설계
- 분기 검증 기준 : **모든 조건문이 한 번 이상 수행**되도록 테스트 케이스 설계
- 조건 검증 기준 : **모든 조건문에 대해 조건이 True인 경우와 False인 경우가 한 번 이상 수행**되도록 테스트 케이스 설계
- 분기/조건 기준 : **모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행**되도록 테스트 케이스 설계
```
// 헷갈리는 문제...
1. 최소 한번은 모든 문장이 수행되도록 구성하는 검증 기준 = 구문(문장) 검증 기준
2. "조건식"이 참(True)/거짓(False)일 때 수행되도록 구성하는 검증 기준 = 결정(분기) 검증 기준
3. 2번과 달리 조건식에 상관없이 "개별 조건"이 참(True)/거짓(False)일 때 수행되도록 구성하는 검증 기준 = 조건 검증 기준
```

##### 2) 블랙박스 테스트
- 각 기능이 완전히 작동되는 것을 입증하는 테스트
- 기능 테스트라고도 함
- 요구사항 명세를 보면서 테스트하는 것
- 소프트웨어 인터페이스에서 실시되는 테스트
##### - 종류
- **동치 분할 검사(Equivalence Partitioning Testing)**
  - 입력 조건이 유효한 경우와 그렇지 않은 경우의 입력 자료의 개수를 균등하게 정하는 검사 기법
- **경계값 분석(Boundary Value Analysis)**
  - 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용한 검사 기법
```
0 <= x <= 10과 같은 조건이 있을 때
경계값 분석 : -1, 0, 10, 11을 입력 값으로
동치 분할 검사 : 0이상 10이하의 수 n개와 0미만 10초과의 수 n개를 입력 값으로 정한다.
```
- 원인-효과 그래프 검사(**Cause-Effect Graphing Testing**)
  - 그래프를 활용하여 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법
  - 오류 예측 검사(Error Guessing)
  - 비교 검사(Comparison Testing)

##### 3) 단위 테스트
- 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 수행하는 테스트로, 모듈 테스트라고도 불린다.
- 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 인터페이스, 외부적 I/O, 자료구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사한다.

##### 4) 통합 테스트
- 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트를 의미하며, 모듈 간 또는 컴포넌트 간의 인터페이스가 정상적으로 실행되는지 검사한다.

------------

### ＊데이터베이스
#### 1. 데이터베이스의 상태 변화를 일으키는 트랜잭션(Transaction)의 특성
- 원자성(Atomicity)
   - 트랜잭션과 관련된 작업들이 모두 정상적으로 수행되거나 아예 하나도 실행되지 않아야한다는 All-or-Nothing 방식을 의미
   - **OR 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야한다는 특성을 의미**
 - 일관성(Consistency)
   - 트랜잭션이 성공적으로 실행되고 난 이후로 데이터베이스가 일관적으로 상태를 유지하는 것을 의미
 - 격리성(Isolation)
   - 하나의 트랜잭션을 통해 SQL 연산이 실행되는 도중에 다른 트랜잭션 연산 작업이 끼어들지 못하게 보장하는 것
 - 지속성(Durability)
   - 트랜잭션이 성공적으로 수행되고 난 이후 시스템의 오류 등과 같은 어떠한 경우에도 데이터가 손실되지 않고 그 결과가 영원히 반영되어야 한다.
참고) https://iwuooh.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Database-Transaction%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-4%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%84%B1?category=982116#:~:text=%EC%9D%B4%EB%A1%A0%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%80,(Durability)%EC%9D%84%20%EB%B3%B4%EC%9E%A5%ED%95%9C%EB%8B%A4.

#### 2. 데이터베이스 설계
- **물리적 설계** : 논리적 구조로 표현된 데이터를 디스크 등의 저장장치에 저장할 수 있는 데이터로 변환하는 과정으로, 파일의 저장 구조 및 액세스 경로를 결정하며, **테이블 정의서 및 명세서가 산출된다.**
- **개념적 설계** : 현실 세계에 대한 인식을 **추상적 개념으로 표현하는 과정으로, 개념 스키마 모델링과 트랜잭션 모델링을 수행하며, 요구 조건 명세를 E-R 다이어그램으로 작성**한다.
- **논리적 설계** : 현실의 자료를 특정 DBMS가 지원하는 자료구조로 변환하는 과정으로, **트랜잭션의 인터페이스를 설계하고, 정규화를 통해 스키마를 평가 및 정제**한다.

#### 3. 데이터 모델의 구성 요소 ★★★★★
1) **구조(Structure)**
- 논리적으로 표현된 개체들 간의 관계를 표시함

2) **연산(Operation)**
- 데이터베이스에 저장된 실제 데이터를 처리하는 방법을 표시함
 
3) **제약조건(Constraint)**
- 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건을 표시함

#### 3-1. 결합도(Coupling)와 응집도(Cohesion)
- 결합도
  - 모듈 내부가 아닌 외부의 모듈과 연관도 또는 모듈 간의 상호의존성을 나타내는 정도
  - 소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도
  - 특징
    - 모듈 연관성 없음
    - 인터페이스 의존성
    - 복잡성 감소
    - 파급효과 최소화
  - 유형(순서대로 결합도가 낮아진다)
    - 내용 결합도(Content Coupling) : 모듈 간의 인터페이스로 데이터, **지역 변수 등을 직접 참조하거나 수정★★★★**할 때의 결합도
    - 공통 결합도(Common Coupling) : 모듈 간의 인터페이스로 파라미터가 아닌 모듈 밖에 선언된 **전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용★★★★**하는 때의 결합도
    - 외부 결합도(External Coupling)
    - 제어 결합도(Control Coupling)
    - 스탬프 결합도(Stamp Coupling) : 모듈 간의 인터페이스로 **배열이나 레코드 등의 자료 구조가 전달★★★★**될 때의 결합도
    - 자료 결합도(Data Coupling)
- 응집도
  - 모듈의 독립성을 나타내는 개념으로, 모듈 내부 구성요소 간 연관 정도
  - 정보 은닉의 확장개념으로 하나의 모듈은 하나의 기능을 수행하는 것을 의미 
  - 특징
    - 유사기능 영역 구성
    - 단일 책임할당
    - 함수 간 상호협력
  - 유형(순서대로 응집도가 높아진다)
    - 우연적 응집도(Coincidental Cohesion) : 모듈 내부의 각 구성요소들이 연관이 없을 경우
    - 논리적 응집도(Logical Cohesion) : 실제와 달리 논리적으로만 같은 그룹으로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우
    - 시간적 응집도(Temporal Cohesion) : 연관된 기능이라기보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우
    - 절차적 응집도(Procedural Cohesion) : 모듈 안의 구성요소들이 서로 다른 기능을 하지만 그 기능을 순차적으로 수행할 경우 = 내부의 요소들이 기능적으로 연관성은 없으나, 순차적으로 실행될 때의 응집도
    - 교환적 응집도(Communication Cohesion) : 서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용할 때의 응집도
    - 순차적 응집도(Sequential Cohesion) : 모듈 내의 한 활동으로부터 나온 출력값을 모듈 내의 다른 활동이 사용할 경우
    - 기능적 응집도(Functional Cohesion) : 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우 = 하나의 기능에 밀접하게 관련되어 있거나 연관되어 있을 때의 응집도
참고) https://itwiki.kr/w/응집도
https://computer-science-student.tistory.com/140


#### 4. 릴레이션 특징 및 용어
![image](https://user-images.githubusercontent.com/24931069/194771321-194394c9-8a5a-4b36-b763-157774c2faa6.png)
```
레코드 또는 튜플(Tuple) : 릴레이션을 구성하는 각각의 행
속성 또는 애트리뷰트(Attribute) : 릴레이션을 구성하는 각각의 열
카디널리티(Cardinality) : 튜플의 수
차수 (Degree) : 애트리뷰트의 수
등등...
```
참고) https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=kookh1&logNo=120184872122

#### 5. 데이터 언어
##### 1) DML(Data Manipulation Language) : 데이터 조작어
```
SELECT, INSERT, UPDATE, DELETE
```
##### 2) DDL(Data Definition Language) : 데이터 정의어
```
CREATE, ALTER, DROP, RENAME, TRUNCATE
```
##### 3) DCL(Data Control Language) : 데이터 제어어
```
★GRANT:데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하는데 사용하는 명령어이다.
REVOKE:
```
##### 4) TCL(Transaction Control Language) : 트랜잭션 제어어
```
COMMIT, ROLLBACK, SAVEPOINT
```
참고) https://brownbears.tistory.com/180


#### 6. SQL문
- 조인
```
교차 조인(CROSS JOIN) :  왼쪽 테이블의 데이터 1개당 오른쪽 테이블 데이터를 처음부터 끝까지 하나씩 결합한다. 그리고 왼쪽의 데이터가 없어질 때까지 반복한다. 
참고) https://araikuma.tistory.com/726
```
- 정렬
```
오름차순:asc (1,2,3,4 ...)
내림차순:desc (4,3,2,1 ...)
```

#### 7. 정규화
```
문제가 생길 수 있는 커다란 테이블을 문제가 없도록 작은 테이블로 나누는 것
하지만 나누는 정도에 따라 규칙(제약조건)이 있고 그 정도를 정규형이라고 부른다
정규형은 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF가 있는데, 
차수가 높아질 수록 규칙(제약조건)이 까다로워진다.
그래서 일반적으로는 1~3NF(또는 ~BCNF)까지만 사용하고 
나머지 정규형은 학문적 용도(전공, 수업, 논문 등)로 사용된다.
```
1. 1NF(제 1정규형) : 테이블(릴레이션)에 각 **도**메인은 원자성(Atomicity)을 가진다.
  - 셀이 더 작게 나눌 수 없는 단일 값을 가진다.
2. 2NF(제 2정규형) : 1NF를 먼저 충족시켜야 진행 가능하고, 속성 값의 결정이 기본키(또는 복합키)의 전체를 참조해야한다.
  - 완전 함수 종속을 만족하도록 테이블을 분해
  - 여기서 완전 함수 종속이란 기본키의 **부**분 집합이 결정자가 되어선 안된다는 것을 의미 
3. 3NF(제 3정규형) : 3NF도 2NF를 충족시킨 상태에서 진행 가능하고, 3NF는 모든 속성이 기본키(또는 복합키)에 **이**행적 함수 종속이 되지 않아야한다.
  - 이행적 함수 종속이란 X->Y고 Y->Z면 X->Z가 되는 것을 말한다.
4. BCNF 정규화 : 제 3정규화를 진행한 테이블에 대해 모든 **결**정자가 후보키가 되도록 테이블을 분해하는 것이다.
5. 4NF(제 4정규형) : **다**치 종속 제거
6. 5NF(제 5정규형) : **조**인 종속성 이용
참고) https://chankim.tistory.com/9

#### 7-2. 반정규화
- 데이터베이스의 성능 향상을 위하여, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다.
- 반정규화는 조회(select) 속도를 향상시키지만, 데이터 모델의 유연성은 낮아진다.
참고) https://sodayeong.tistory.com/106

#### 7-3. 정규화/반정규화 차이
```
정규화는 기본적으로 데이터 중복성을 제거해주기 때문에(쪼개주기 때문에) 
성능 자체는 향상되는 특징을 가지고 있습니다. 
하지만 그만큼 조인이 많이 발생하기 때문에 
그에 따른 성능저하가 나타나는 경우가 있을 수 있죠. 

한가지 테이블안에서 어차피 조인이 가능하다면 
굳이 정규화를 진행할 필요가 없겠죠.
혹은 정규화가 되어있더라 하더라도 성능을 고려하여 
반정규화를 진행하는 것이 더 효율적일 수 있기 때문에 반정규화를 하게 됩니다.

하지만 무분별한 반정규화는 데이터 무결성을 깨뜨리는 역할을 하게 된다고합니다.
즉 성능의 이슈와 데이터 무결성의 보존 사이에서 정규화와 반정규화를 고려하게 되는것이죠.

정규화 반정규화 차이 참고) https://okky.tistory.com/39
```

#### 8. 로킹(Locking)
- 데이터베이스의 병행제어 기법 중 하나
- 접근한 데이터에 대한 연산을 모두 마칠 때까지 추가적인 접근을 제한함으로써 상호 배타적으로 접근하여 작업을 수행하도록 하는 기법
```
쉽게 설명)
한번에 한명만 사용할 수 있게 하는 단위를 "로킹 단위"라 하는데
ex) 어떤 프로젝트의 소스를 여러 사람이 동시에 작업할 경우,
    누군가가 특정 파일을 건들고 있을 때, 
    다른 사용자는 그 파일을 건들지 못하도록 하는 것이 로킹
    이 때 로킹 단위 = 파일이 된다.
ex) 어떤 사람이 어떤 폴더에 있는 파일을 작업하고 있을 때
    그 폴더에 아예 접근 못하게 하게 되면
    이 때 로킹 단위 = 폴더가 된다.
ex) 한명씩 차례로 작업할 수만 있고, 누군가가 작업 중이고
    아예 프로젝트에 접근 못하도록 한다면,
    이 때 로킹 단위 = 프로젝트가 된다.
```
```
이 때 단위별로 나누어진 하나하나를 '로크'라고 하는데
로킹 단위를 '파일'로 하자면, 
파일 하나하나가 '로크'가 되니 당연히 그 수가 많아질테고
로킹 단위를 '폴더'로 하자면 훨씬 줄어들테고
로킹 단위를 '프로젝트'로 하면 로크는 1개밖에 없게 된다.

따라서 데이터베이스 트랜젝션에서도 로킹 단위는 파일, 레코드, 필드와 같이 여러가지로 나누어질 수도 있고

로킹 단위가 크면(ex프로젝트) -> 로크의 수가 적어지고 -> 제어 기법이 간단해지고 -> 병행성이 감소한다.
로킹 단위가 작으면(ex파일) -> 로크의 수가 많아지고 -> 제어하기 까다로우며 -> 병행성이 증가한다.
```
참고) https://raisonde.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%A1%9C%ED%82%B9Locking-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EB%A1%9C%ED%82%B9-%EB%8B%A8%EC%9C%84

#### 9. 데이터베이스 회복 기법
- 트랜잭션들을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업
- 회복 기법
  - 로그 기반 회복 기법
    - 지연 갱신 회복 기법(Deferred Update)
    - 즉시 갱신 회복 기법(Immediate Update)
      - 트랜잭션이 데이터를 변경하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 DB에 그 내용을 반영하는 기법
      - 장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들을 로그에 보관시킨다.
      - 회복 작업을 수행할 경우 Redo와 Undo 모두 수행이 가능하다.
  - 검사점 회복 기법(Checkpoint Recovery)
  - 그림자 페이징 회복 기법(Shadow Paging Recovery)
  - 미디어 회복 기법(Media Recovery)
  - ARIES 회복 기법
    - REDO 중 Repeating history
    - UNDO 중 Logging
참고) https://itwiki.kr/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%ED%9A%8C%EB%B3%B5

------------

### ＊네트워크
#### OSI 7 Layer
- 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocal)이다.
```
물리(Physical) 계층
데이터링크(Data-Link) 계층 : 물리적으로 연결된 두 개의 인접한 개방 시스템들 간에 신뢰성있고 효율적인 정보 전송을 할 수 있도록 연결 설정, 데이터 전송, 오류 제어 등의 기능을 수행한다.
네트워크(Network) 계층 : 개방 시스템들 간의 네트워크 연결을 관리하며, 경로 제어, 패킷 교환, 트래픽 제어 등의 기능을 수행한다.
전송(Transport) 계층
세션(Session) 계층 
표현(Presentation) 계층 : 서로 다른 데이터 표현 형태를 갖는 시스템의 상호 접속을 위해 필요한 계층으로, 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색 등의 기능을 수행한다.
응용(Application) 계층
```

#### 패킷 교환 방식
- 패킷 교환 방식은 접속 방식에 따라서 데이터 그램 방식과 가상회선 방식으로 구분된다.
![image](https://user-images.githubusercontent.com/24931069/194769028-99e2dae3-1a3a-49fd-b89f-cd3fcdd5cdfb.png)
##### 1) 데이터그램
- **비연결형 통신에서 주로 사용하는 방식으로, 사전에 접속 절차를 수행하지 않고 헤더에 출발지에서 목적지까지의 경로 지정을 위한 충분한 정보를 붙여서 개별적으로 전달하는 방식**
- 데이터를 전송하기 전에 논리적 연결이 설정되지 않으며 패킷이 독립적으로 전송된다.
- 패킷을 수신한 라우터는 최적의 경로를 선택하여 패킷을 전송하는데 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있다.(비연결 지향형)
- 송신 측에서 전송한 순서와 수신 측에 도착한 순서가 다를 수 있다.

##### 2) 가상회선(VC)
![image](https://user-images.githubusercontent.com/24931069/194769043-73ac16f0-b0ec-4698-a774-da4be15a74c1.png)
- **연결형 통신에서 주로 사용되는 방식으로, 출발지와 목적지의 전송 경로를 미리 연결하여 논리적으로 고정한 후 통신하는 방식**
- 데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 한다.(연결 지향형)
- 각 패킷에는 가상회선 식별 번호(VCI)가 포함되고, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착한다.
- 데이터 그램은 패킷마다 라우터가 경로를 선택하지만, 가상회선 방식은 경로를 설정할 때 한 번만 수행한다.
참고) [https://jineer.tistory.com/50](https://woovictory.github.io/2018/12/28/Network-Packet-Switching-Method/)

#### Ad-hoc Network
- 재난 및 군사 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크이다.
- 망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합하다.
- 멀티 홉 라우팅 기능을 지원한다.

#### IPC(Inter-Process Communication)
- 프로세스들 간의 의사소통하는 것을 IPC라고 한다.
- 프로세스가 통신 가능하다는 것은 서로 다른 프로세스가 데이터를 주고 받을 수 있다는 것이며, 동시에 접근 가능한 메모리, 즉, 프로세스들이 공유하는 메모리가 필요하다는 것이다.
- 따라서 컴퓨터 내부에서 보다 효율적으로 정보를 주고 받기 위한 통신의 일종이라고 생각하면 되고, 인터넷 통신을 IPC의 확장으로 이해할 수 있다.
- **모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합으로, 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다. 대표적인 메소드에는 공유 메모리, 소켓, 세마포어, 파이프와 네임드 파이프, 메시지 큐잉이 있다.**
참고) https://dar0m.tistory.com/233

#### RARP
- 인터넷 환경에서의 호스트 상호 간 통신에서 연결된 네트워크 접속 장치의 물리적 주소인 MAC 주소를 이용하여 IP 주소를 찾는 인터넷 계층의 프로토콜로, 역순 주소 결정 프로토콜이라 불린다.

------------

### * 인터넷
#### IPv4
- 32비트의 주소를 가지며 8비트씩 4부분, 총 32비트로 구성되어 있다. IPv4는 네트워크 부분의 길이에 따라 A클래스에서 E클래스까지 총 5단계로 구성되어 있다.

#### IPv6
- 128비트의 주소를 가지며, 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있고, 주소의 확장성, 융통성, 연동성이 뛰어나다.

------------

### ＊프로그래밍
#### 1. 연산
- True / False
```
true : 1
false : 0
```
- 비트 연산
```
& : 모두 1이면 1 반환
| : 하나라도 1이면 1반환
~ : 반전
^(XOR) : 서로 다르면 1 반환, **즉 다르면 1, 같으면 0**
<< : 지정한 수만큼 비트들을 전부 왼쪽으로 이동
>> : 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동
```

#### 2. Python
False, True

```
lol = [[1,2,3], [4,5], [6,7,8,9]]
print(lol[0])
print(lol[2][1])
for sub in lol:
  for item in sub:
    print(item, end=' ')
  print()
  
// [1,2,3]
// 7
// 1 2 3
// 4 5
// 6 7 8 9
```

#### 3. C
##### 1) 구조체
- 구조체의 멤버를 지정할 때는 [변수명].[멤버이름]으로 지정하지만 포인터 변수를 이용해 구조체의 멤버를 지정할 때는 [변수명]->[멤버이름]으로 지정한다.
```
...

struct jsu {
  char nae[12];
  int os, db, hab, hhab;
};

int main() {
  struct jsu st[3] = { {"데이터1", 95, 88}, {"데이터2", 84, 91}, {"데이터3", 86, 75} };
  struct jsu *p;
  p = &st[0];
  (p+1)->hab = (p+1)->os + (p+2)->db;
  (p+1)->hhab = (p+1)->hab + p->os + p->db;
  printf("%d", (p+1)->hab + (p+1)->hhab);
}
// 501
```
```
        char nae[12]              int os   int db     int hab     int hhab
st[0]   |데|이|터|1|\0| | | | |    95        88
st[1]   |데|이|터|2|\0| | | | |    84        91
st[2]   |데|이|터|3|\0| | | | |    86        75
```

##### 2) 포인터
1.
```
...

int* array[3];
int a = 12, b = 24, c = 36;
array[0] = &a;
array[1] = &b;
array[2] = &c;

*array[1] : array[1]의 주소값이 가리키는 곳의 값 = 24
**array : array의 주소값이 가리키는 곳의 값 = 12
```
2.
```
...
struct insa {
  char name[10];
  int age;
} a[] = { "Kim", 28, "Lee", 38, "Park", 42, "Choi", 31 };
struct insa* p;
p = a;
p++; // p = p + 1, p의 값을 1 증가시킨다. 
// 주소에 1을 더하는 것은 다음 자료를 가리키라는 것을 의미하므로 p는 a[1]의 위치를 가리키게 된다.
// 즉 a->name은 Lee, a->age는 38
```
3. A -> 65
```
...

char* p = "KOREA"; 
// 문자열을 저장하는 경우 
// 문자열의 끝을 의미하는 널 문자('\0')가 추가로 저장되며 
// 출력 시 널 문자는 표시되지 않습니다.

printf("%s\n", p);
printf("%s\n", p+3); // p+3의 위치부터 문자열의 끝("\0")까지 모든 문자를 하나의 문자열로 출력 
printf("%c\n", *p); // p가 가리키는 곳의 문자 출력, *p = *(p+0)
printf("%c\n", *(p+3));
printf("%c\n", *p+2);
// KOREA라는 문자열이 메모리에 저장될 때 문자로 저장되는 것이 아니라
// 해당 문자의 아스키 코드 값이 저장됩니다.
// 즉 K는 K에 해당하는 아스키 코드 값인 75가 저장됩니다.
// *p = 75 + 2 = 77
// 77을 문자로 출력한다는 것은 알파벳 순서 상 K의 다다음 문자인 M 출력

// KOREA
// EA
// K
// E
// M
```
4.
```
#include <stdio.h>
main() {
  struct insa {
    char name[10];
    int age;
  } a[] = { "Kim", 28, "Lee", 38, "Park", 42, "Choi", 31 };
  struct insa *p;
  p = a;
  p++; // 주소에 1을 더하는 것은 다음 자료를 가리키라는 것을 의미하므로 p는 a[1]의 위치를 가리키게 된다.
  printf("%s\n", p->name);
  printf("%d\n", p->age);
}
// Lee
// 38
```

------------

#### JAVA
1.
```
class Connection {
  private static Connection _inst = null; 
  // 객체 변수를 선언만 하게 되면 heap이 아닌 stack 영역에 내용 없이 저장되어 사용이 불가능
  // new가 사용되어야만 heap 영역에 내용이 저장되고 
  // 그 주소도 객체 변수에 전달되면서 사용 가능한 객체 변수가 됩니다.
  private int count = 0;
  public static Connection get() {
    if(__inst == null) {
      _inst = new Connection(); 
      // _inst가 null일 때만 딱 한 번 객체 변수 생성,
      // 객체 변수를 생성한다는 것은
      // 객체 생성 예약어인 new를 통해 heap 영역에 공간을 확보하여
      // Connection 클래스의 내용을 저장한 후 그 주소를 객체 변수에 저장하는 것
      return _inst;
    }
    return _inst;
  }
  public void count() { count++; }
  public int getCount() { return count; }
}

public Test {
  public static void main(String[] args) {
    Connection conn1 = Connection.get(); 
    conn1.count();
    Connection conn2 = Connection.get();
    conn2.count();
    Connection conn3 = Connection.get(); // 주소값을 객체 변수에 저장
    conn3.count(); // 같은 주소 값을 사용하니
    System.out.print(conn1.getCount()); // 1+1+1 = 3이 된다.
  }
}
// 3
```
2.
```
public class Test {
  public static void main(String[] args) {
      int aa[][] = { {45,50,75}, {89} };
      System.out.println(aa[0].length);
      System.out.println(aa[1].length);
      System.out.println(aa[0][0]);
      System.out.println(aa[0][1]);
      System.out.println(aa[1][0]);
  }
} 
// 3
// 1
// 45
// 50
// 89
```
2.
```
public class Test {
  public static void main(String[] args) {
    int j, i;
    for(j=0, i=0; i<=5; i++) {
      j += i;
      System.out.print(i);
      if(i==5) {
        System.out.println("=");
        System.out.println(j); // println과
      } else {
        System.out.print("+"); // print 구분 잘할 것!
      }
    }
  }
}
// 0+1+2+3+4+5=15
    
```


### ＊보안

#### 암호화 알고리즘
- DES
   - 1974년 IBM이 개발하고 1975년 NBS에 의해 미국의 국가 표준으로 발표된 암호화 알고리즘
   - 블록 크기는 64비트, 키 길이는 56비트이며, 16회의 라운드를 수행한다.
   - 컴퓨터 기술이 발달함에 따라 해독이 쉬워지면서 미국의 국가 표준이 2001년 AES로 대체되었다.
- AES
   - 2001년 미국 표준 기술 연구소(NIST)에서 발표한 대칭키 암호화 알고리즘이다.
   - DES의 한계를 느낀 NIST에서 공모한 후 발표하였다.
   - 블록 크기는 128비트이며, 키 길이에 따라서 128, 192, 256으로 분류된다.

#### 데이터베이스 보안 ★★★★★
- 접근 통제 : 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것
  - 접근 통제 기술
    - 임의 접근 통제(DAC) ★★★★★
      - 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하여 제어하는 방식으로 데이터의 소유자가 접근통제 권한을 지정하고 제어한다.
      - 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가할 수도 있다.
    - 강제 접근 통제(MAC)
      - 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
      - 시스템이 접근통제 권한을 지정함
      - 데이터베이스 객체별로 보안 등급을 부여할 수 있음
      - 사용자별로 인가 등급을 부여할 수 있음
    - 역할 기반 접근 통제(RBAC)
참고) https://velog.io/@ssook1222/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%EC%8A%A4%ED%84%B0%EB%94%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B3%B4%EC%95%88

### 공격 기법
- ARP 스푸핑 : 로컬 네트워크(LAN)에서 사용하는 ARP 프로토콜의 취약점을 이용한 공격 기법으로, 자신의 물리적 주소(MAC)를 변조하여 다른 PC에 도달해야 하는 데이터 패킷을 가로채거나 방해한다.
- 세션 하이재킹 : '세션을 가로채다'라는 의미로, 정상적인 연결을 RST 패킷을 통해 종료시킨 후, 재연결 시 희생자가 아닌 공격자에게 연결하는 공격 기법
- TCP 세션 하이재킹 : 공격자가 TCP 3-Way Handshake 과정에 끼어듦으로써 서버와 상호 간의 동기화된 시퀀스 번호를 갖고 인가되지 않은 시스템의 기능을 이용하거나 중요한 정보에 접근할 수 있게 된다.
- 스니핑 : 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형
- 스푸핑 : TCP/IP의 구조적 결함을 이용해 사용자의 시스템 권한을 획득한 뒤 정보를 빼가는 

### 기타 용어
#### WSDL(Web Services Description Language)
- 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어로, XML로 작성되며 UDDI의 기초가 된다. SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해, 클라이언트는 이것을 통해 서버에서 어떠한 조작이 가능한지를 파악할 수 있다.

#### 오버로딩 / 오버라이딩(그냥 궁금해서...)
1. 오버로딩
```
// 같은 이름의 메서드(함수)를 여러개 가지면서 매개변수 유형과 개수가 다르도록 하는 것
// https://velog.io/@ohsol/JAVA-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9%EA%B3%BC-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%B0%A8%EC%9D%B4%EC%99%80-%EC%98%88%EC%A0%9C
class TestOverloading {
  // 매개변수가 없는 sol 메서드
	void sol() {
    	System.out.println("매개변수가 없습니다");
  }
  // 매개변수가 int형 2개인 sol 메서드
	void sol(int a, int b) {
    	System.out.println("매개변수" + a + "와" + b);
  }
  // 매개변수가 String형 1개인 sol 메서드
	void sol(String c) {
    	System.out.println("매개변수" + c);
  }
}

public class TestOverLoad {
	public static void main(String[] args) {
    	TestOverloading ob = new TestOverloading();
        ob.sol();
        ob.sol(1,2);
        ob.sol("오버로딩 테스트");
    }
}
// 이와 같이 sol 메서드가 3개지만, 매개변수 유형과 개수가 다름
// 호출 매개변수에 따라 맞는 함수를 실행함
```
2. 오버라이딩(Overriding)
```
상위 클래스가 가지고 있는 메서드도 하위 클래스로 상속되어 하위 클래스에 사용
하위 클래스에서 메서드를 재정의해서 사용할 수 있음
쉽게 말해 메서드 이름이 같고, 매개변수가 같고, 반환형이 같을 경우 상속받은 메서드를 덮어쓴다고 생각하면 됨
'부모 클래스의 메서드는 무시하고, 자식 클래스의 메서드 기능을 사용하겠다' 와 같음

//부모 클래스
class Woman {
	public String name;
    public int age;
    
    public void info() {
    	System.out.println("여자 이름은 "+name+", 나이는 "+age+"살");
    }
}

// Woman 클래스 상속받은 Job 클래스
class Job extends Woman {
	String job;
    
    // 부모 클래스(Woman)에 있는 info 메서드 재정의
    public void info() {
        System.out.println("여자의 직업은 "+job+"입니다.");
    }
}


public class TestOverRide {
	public static void main(String[] args) {
        
        //Job 객체 생성
        Job job = new Job();
        
        //변수 설정
        job.name = "솔이";
        job.age = 26;
        job.job = "개발자";
        
        //호출
        job.info();
        
    }  
}
```
